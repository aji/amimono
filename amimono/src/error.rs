use std::fmt;

use axum::response::IntoResponse;
use serde::{Deserialize, Serialize};

use crate::retry::RetryError;

pub type Result<T> = std::result::Result<T, Error>;
pub type AppResult<T> = std::result::Result<T, AppError>;

/// Errors that can be generated by Amimono
#[derive(Debug)]
pub enum Error {
    Internal(String),
    User(String),
    App(AppError),
    Other(Box<dyn std::error::Error>),
}

impl fmt::Display for Error {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Error::Internal(s) => write!(f, "internal error: {s}"),
            Error::User(s) => write!(f, "{s}"),
            Error::App(e) => write!(f, "{e}"),
            Error::Other(e) => write!(f, "{e}"),
        }
    }
}

impl std::error::Error for Error {}

impl From<String> for Error {
    fn from(value: String) -> Self {
        Error::Internal(value)
    }
}

impl From<&str> for Error {
    fn from(value: &str) -> Self {
        Error::Internal(value.to_owned())
    }
}

impl From<AppError> for Error {
    fn from(value: AppError) -> Self {
        Error::App(value)
    }
}

/// A trait for errors that can be generated by application code.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub enum AppError {
    /// A spurious error with an unstructured string message. These can
    /// generally be assumed to be recoverable.
    Spurious(String),

    /// A miscellaneous error with an unstructured string message. These should
    /// generally be assumed to be unrecoverable. Converting a string via `From`
    /// will generate an error of this type.
    Misc(String),

    /// An error together with a component label. This variant is constructed
    /// when an error crosses a component boundary within Amimono, e.g. when
    /// using `RpcClient`, and can be nested several layers deep.
    Downstream(String, Box<AppError>),
}

impl AppError {
    /// Create a spurious error
    pub fn spurious<S: ToString>(msg: S) -> AppError {
        AppError::Spurious(msg.to_string())
    }

    /// Create a misc error
    pub fn misc<S: ToString>(msg: S) -> AppError {
        AppError::Misc(msg.to_string())
    }

    /// Unwrap layers of caused-by nesting to get the innermost error.
    pub fn root_cause(&self) -> &AppError {
        match self {
            AppError::Downstream(_, e) => e.root_cause(),
            _ => self,
        }
    }
}

impl RetryError for AppError {
    fn should_retry(&self) -> bool {
        match self {
            AppError::Spurious(_) => true,
            AppError::Misc(_) => false,
            AppError::Downstream(_, e) => e.should_retry(),
        }
    }
}

impl std::error::Error for AppError {}

impl IntoResponse for AppError {
    fn into_response(self) -> axum::response::Response {
        let res = (
            axum::http::StatusCode::INTERNAL_SERVER_ERROR,
            axum::Json(self),
        );
        res.into_response()
    }
}

impl fmt::Display for AppError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            AppError::Spurious(s) => write!(f, "spurious: {s}"),
            AppError::Misc(s) => write!(f, "rpc error: {s}"),
            AppError::Downstream(at, e) => write!(f, "{at}: {e}"),
        }
    }
}

impl From<String> for AppError {
    fn from(s: String) -> Self {
        AppError::Misc(s)
    }
}

impl From<&str> for AppError {
    fn from(value: &str) -> Self {
        AppError::Misc(value.to_owned())
    }
}

impl From<crate::error::Error> for AppError {
    fn from(value: crate::error::Error) -> Self {
        AppError::Misc(format!("amimono error: {value}"))
    }
}

impl From<reqwest::Error> for AppError {
    fn from(value: reqwest::Error) -> Self {
        if value.is_timeout() {
            let origin = match value.url() {
                Some(u) => u.origin().ascii_serialization(),
                None => "(unknown)".to_owned(),
            };
            AppError::Spurious(format!("http timeout at {origin}"))
        } else {
            AppError::Misc(format!("http error: {value}"))
        }
    }
}

impl From<serde_json::Error> for AppError {
    fn from(value: serde_json::Error) -> Self {
        AppError::Misc(format!("json error: {value}"))
    }
}

impl From<std::io::Error> for AppError {
    fn from(value: std::io::Error) -> Self {
        AppError::Misc(format!("io error: {value}"))
    }
}

impl From<tokio::task::JoinError> for AppError {
    fn from(value: tokio::task::JoinError) -> Self {
        match value.try_into_panic() {
            Ok(e) => std::panic::resume_unwind(e),
            Err(e) => match e.is_cancelled() {
                true => AppError::Misc(format!("task cancelled")),
                false => AppError::Misc(format!("tokio join error")),
            },
        }
    }
}
